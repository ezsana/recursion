package com.codecool.zsana.recursion;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

public class MIT {

    /**
     * Each of the following two procedures defines a method for adding two positive integers
     * in terms of the procedures inc, which increments its argument by 1, and dec,
     * which decrements its argument by 1.
     * Using the substitution model, illustrate the process generated by each procedure
     * in evaluating aPlusB(4,5). Are these processes iterative or recursive?
     * -------------
     * Tail recursion in both cases but is the second one iterative?
     */

    static int aPlusB(int a, int b) {
        if (a == 0) {
            return b;
        }
        return inc(aPlusB(dec(a), b));
    }

    static int bPlusA(int a, int b) {
        if (a == 0) {
            return b;
        }
        return bPlusA(dec(a), inc(b));
    }

    static int inc(int x) {
        return ++x;
    }

    static int dec(int y) {
        return --y;
    }

    /**
     * The following procedure computes a mathematical function called Ackermann's function.
     *
     * What are the values of the following expressions?
     *
     *  (A 1 10) --> 2^10
     *
     *  (A 2 4) --> 2^16
     *
     *  (A 3 3) --> 3,1 == 2; 3,2 == 4; 3,3 == 65536; 3,4 == stackoverflow
     *
     * Consider the following procedures, where A is the procedure defined above:
     *
     *  (define (f n) (A 0 n)) --> 2*n
     *
     *  (define (g n) (A 1 n)) --> 2^n
     *
     *  (define (h n) (A 2 n)) --> 2,2 == 4; 2,3 == 16; 2,4 == 65536; 2,5 == stackoverflow
     *
     *  (define (k n) (* 5 n n))
     *
     * Give concise mathematical definitions for the functions computed
     * by the procedures f, g, and h for positive integer values of n. For example, (k n) computes 5n2.
     */

    static long ackermann(long x, long y) {
        if (y == 0) { return 0; }
        if (x == 0) { return 2 * y; }
        if (y == 1) { return 2; }
        return ackermann((x - 1), (ackermann(x, (y - 1))));
    }

    /**
     * Fibonacci - iterative / recursive -> b == 0,1,1,2,3,...
     */

    static int fib(int n) {
        return fibIter(0 ,1, n);
    }

    static int fibIter(int a, int b, int count) {
        if (count == 0) { return a; }
        return fibIter(b, (a+b), (count - 1));
    }

    /**
     * Counting change - coins: 1,5,10,25,50;
     */

    static int countChange(int amount) {
        return cc(amount, 3);
    }

    static int cc(int amount, int kindOfCoins) {
        if (amount == 0) return 1;
        if (amount < 0 || kindOfCoins == 0) return 0;
        return cc(amount, (kindOfCoins - 1)) + cc(amount - firstDenomination(kindOfCoins), kindOfCoins);
    }

    static int firstDenomination(int kindsOfCoins) {
        if (kindsOfCoins == 1) return 1;
        if (kindsOfCoins == 2) return 5;
        if (kindsOfCoins == 3) return 10;
        if (kindsOfCoins == 4) return 25;
        if (kindsOfCoins == 5) return 50;
        return -1;
    }

    /**
     * A function f is defined by the rule that f(n) = n if n<3 and f(n) = f(n - 1) + 2f(n - 2) + 3f(n - 3) if n> 3.
     * Write a procedure that computes f by means of a recursive process. Write a procedure that
     * computes f by means of an iterative process.
     */

    static int f(int n) {
        if (n < 3) return n;
        return f(n-1) + 2 * f(n-2) + 3 * f(n-3);
    }

    // ????????
    static int fIter(int n) {
        if (n < 3) return n;
        return 0;
    }

    /**
     * The following pattern of numbers is called Pascal's triangle.
     *              1
     *            1   1
     *          1   2   1
     *         1  3   3  1
     * The numbers at the edge of the triangle are all 1, and each number inside the triangle
     * is the sum of the two numbers above it.35 Write a procedure that computes elements of
     * Pascal's triangle by means of a recursive process.
     */

    static int[] pascalRecursive(int row) {
        return null;
    }

    static int pIt(int firstXSum) {
        int sum = 0;
        for (int i = 1; i <= firstXSum; i++) {
            sum += i;

        }
        return sum;
    }

    static int pRec(int firstXSum) {
        if (firstXSum <= 1) return firstXSum;
        return firstXSum + pRec(firstXSum-1);
    }

    static List<Integer> pascalIter(int row) {
        List<Integer> numbers = new ArrayList<Integer>();
        if (row < 2) numbers.add(1);
        numbers.add(1);
        numbers.add(1);
        for (int i = 2; i < row; i++) {
            List<Integer> temp = new ArrayList<Integer>();
            temp.add(1);
            for (int y = 0; y < numbers.size()-1; y++) {
                temp.add(numbers.get(y) + numbers.get(y+1));
            }
            temp.add(1);
            numbers = temp;
        }
        return numbers;
    }

    public static void main(String[] args) {

    }

}
